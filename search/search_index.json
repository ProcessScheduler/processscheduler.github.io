{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"buffer/","title":"Buffers","text":"<p>A <code>Buffer</code> is an object where tasks can load or unload a finite number of items. A <code>Buffer</code> can be used to represent a tank, or a temporary buffer of a workshop where manufactured parts are temporarily stored.</p> <p>A <code>NonConcurrentBuffer</code> is a specific buffers where tasks cannot load and/or unload at the same time. In other words, only one task can access the buffer at a given time. A `NonConcurrentBuffer`` has three main attributes:</p> <ol> <li>the <code>initial_level</code>, i.e. the number of items in the buffer for time t=0,</li> <li>the <code>lower_bound</code>, an optional parameter that sets the minimum number of items in the buffer during the schedule. If ever the solver cannot find a solution where the buffer level is always greater than the <code>lower_bound</code>, it will report an unsatisfiable problem,</li> <li>the <code>upper_bound</code>, an optional parameter that sets the maximum number of items in the buffer during the schedule (in other words, the buffer capacity). If ever the solver cannot find a solution where the buffer level is always lower than the <code>upper_bound</code>, it will report an unsatisfiable problem.</li> </ol> <p>Both <code>initial_level</code>, <code>lower_bound</code> and <code>upper_bound</code> are optional parameters. A <code>NonConcurrentBuffer</code> can be created as follows:</p> <pre><code>buff1 = ps.NonConcurrentBuffer(\"Buffer1\")\nbuff2 = ps.NonConcurrentBuffer(\"Buffer2\", initial_state=10)\nbuff3 = ps.NonConcurrentBuffer(\"Buffer3\", lower_bound=0)\nbuff4 = ps.NonConcurrentBuffer(\"Buffer4\", upper_bound=20)\nbuff5 = ps.NonConcurrentBuffer(\"Buffer5\",\n                               initial_state=3,\n                               lower_bound=0, \n                               upper_bound=10)\n</code></pre>"},{"location":"buffer/#buffer-constraints","title":"Buffer constraints","text":"<p>Buffers are loaded/unloaded by tasks. As a consequence, special tasks constraints are used to connect tasks to buffers: <code>TaskUnloadBuffer</code> and <code>TaskLoadBuffer</code>. Both classes take the task instance, the target buffer, and a <code>quantity</code>. Load/Unload constraints can be created as follows:</p> <pre><code>c1 = ps.TaskUnloadBuffer(task_1, buffer, quantity=3)\nc2 = ps.TaskUnloadBuffer(task_2, buffer, quantity=6)\n# etc.\n</code></pre> <p>Note</p> <p>There is no limitation on the number of buffers and/or buffer constraints.</p>"},{"location":"buffer/#example","title":"Example","text":"<p>Let's take an example where a task :const:<code>T1</code> uses a machine :const:<code>M1</code> to manufacture a part (duration time for this task is 4). It takes one part in a :const:<code>Buffer1</code> and loads the :const:<code>Buffer2</code>.</p> <pre><code>machine_1 = ps.Worker('M1')\ntask_1 = ps.FixedDurationTask('T1', duration=4)\ntask_1.add_required_resource(machine_1)\n# the create buffers\nbuffer_1 = ps.NonConcurrentBuffer(\"Buffer1\", initial_state=5)\nbuffer_2 = ps.NonConcurrentBuffer(\"Buffer2\", initial_state=0)\n# buffer constraints\nc1 = ps.TaskUnloadBuffer(task_1, buffer_1, quantity=1)\nc2 = ps.TaskLoadBuffer(task_1, buffer_2, quantity=1)\n</code></pre> <p>The graphical output shows the Gantt chart and the evolution of the buffer states along the time line.</p> <p></p>"},{"location":"first_order_logic_constraints/","title":"First order logic constraints","text":"<p>Builtin constraints may not be sufficient to cover the large number of use-cases user may encounter. Rather than extending more and more the builtin constraints, ProcessScheduler lets you build your own constraints using logical operators, implications and if-then-else statement between builtin constraints or class attributes.</p>"},{"location":"first_order_logic_constraints/#logical-operators","title":"Logical operators","text":"<p>Logical operators and (:math:<code>\\wedge</code>), or (:math:<code>\\lor</code>), xor (:math:<code>\\oplus</code>), not (:math:<code>\\lnot</code>) are provided through the functions :func:<code>and_</code>, :func:<code>or_</code>, :func:<code>xor_</code> and :func:<code>not_</code>.</p> <p>Note</p> <p>Take care of the trailing underscore character at the end of the function names. They are necessary because :const:<code>and</code>, :const:<code>or</code>, and :const:<code>not</code> are python keywords that cannot be overloaded. This naming convention may conflict with functions from the :mod:<code>operator</code> standard module.</p> <p>Using builtin task constraints in combination with logical operators enables a rich expressivity. Imagine that you need a task :math:<code>t_1</code> to NOT start at time 3. At a first glance, you can expect a <code>TaskDontStartAt</code> to fit your needs, but it is not available from the builtin constraints library. The solution is to express this constraint in terms of first order logic, and state that you need the rule:</p> \\[\\lnot TaskStartAt(t_1, 3)\\] <p>In python, this gives:</p> <pre><code>not_(TaskStartAt(t_1, 3)\n</code></pre> <p>You can combine/nest any of these operators to express a complex constraint. For example, if you don't want the task to start at 3, and also you don't want it to end at 9, then the rule to implement is:</p> \\[\\lnot TaskStartAt(t_1,3) \\wedge \\lnot TaskEndsAt(t_1, 9)\\] <p>In python:</p> <pre><code>and_([not_(TaskStartAt(t_1, 3)),\n      not_(TaskEndAt(t_1, 9))])\n</code></pre> <p>In a more general cas, those logical functions can take both task constraints or tasks attributes. For example, the following assertion is possible :</p> <pre><code>problem.add_constraint(t1.start == t_2.end + t_4.duration)\n</code></pre>"},{"location":"first_order_logic_constraints/#logical-implication-conditional-expressions","title":"Logical Implication - Conditional expressions","text":"<p>The logical implication (\\(\\implies\\)) is wrapped by the <code>Implies</code> class. It takes two parameters: a condition, that always has to be :const:<code>True</code> or :const:<code>False</code>, and a list of assertions that are to be implied if the condition is :const:<code>True</code>. For example, the following logical implication:</p> \\[t_2.start = 4 \\implies TasksEndSynced(t_3, t_4)\\] <p>is written in Python:</p> <pre><code>consequence = implies(t_2.start == 4,\n                      [TasksEndSynced(t_3, t_4)]\nproblem.add_constraint(consequence)\n</code></pre> <p>Finally, an if/then/else statement is available through the function :func:<code>if_then_else</code> which takes 3 parameters: a condition and two lists of assertions that applies whether the condition is :const:<code>True</code> or :const:<code>False</code>.</p> <pre><code>ite = if_then_else(t_2.start == 4,  # condition\n                   [TasksEndSynced(t_3, t_4)], # if the condition is True\n                   [TasksStartSynced(t_3, t_4)]) # if the condition is False\nproblem.add_constraint(ite)\n</code></pre> <p>Note</p> <p>The classes <code>Implies</code> and <code>If_then_else</code> functions names do not conflict with any other function name from another package, thus dont have any underscore suffix.</p>"},{"location":"indicator/","title":"Indicator","text":""},{"location":"indicator/#create-an-indicator-instance","title":"Create an Indicator instance","text":"<p>The <code>Indicator</code> class allows to define a criterion that quantifies the schedule so that it can be compared with other schedules. An <code>Indicator</code> instance results in a conclusion such a 'the schedule A is better than schedule B because the indicator XXX is greater/lower'.</p> <p>An <code>Indicator</code> instance is created by passing the indicator name as well as the mathematical expression to compute. For example:</p> <pre><code>flow_time = Indicator('FlowTime', task1.end + task2.end)\nduration_square = Indicator('MinTaskDuration', task1.duration ** 2 + task2.duration ** 2)\n</code></pre> <p>Indicator values are computed by the solver, and are part of the solution. If the solution is rendered as a matplotlib Gantt chart, the indicator values are displayed on the upper right corner of the chart.</p> <p>Indicators can also be bounded, although it is an optional feature. It is useful if the indicator is further be maximized (or minimized) by an optimization solver, in order to reduce the computation time. For example,</p> <pre><code>indicator1 = Indicator('Example1', task2.start - task1.end, bounds = (0,100)) # If lower and upper bounded\nindicator2 = Indicator('Example2', task3.start - task2.end, bounds = (None,100)) # If only upper bounded\nindicator3 = Indicator('Example3', task4.start - task3.end, bounds = (0,None)) # If only lower bounded\n</code></pre> <p>Note</p> <p>There is no limit to the number of Indicators defined in the problem. The mathematical expression must be expressed in a polynomial form and using the <code>Sqrt</code> function. Any other advanced mathematical functions such as <code>exp</code>, <code>sin</code>, etc. is not allowed because not supported by the solver.</p>"},{"location":"indicator/#builtin-indicators-resource-cost-utilization-number-of-tasks-assigned","title":"Builtin indicators : Resource cost, utilization, number of tasks assigned","text":"<p>Two usual indicators are available : the utilization and cost of a resource (or a list of resources).</p> <p>Use the <code>add_indicator_resource_utilization</code> method to insert a cost computation to your schedule. This method takes a list of resources and compute the total cost (sum of productivity * duration for all resources). The result is a percentage: an utilization of 100% means that the resource is assigned 100% of the schedule timeline. In the following example, the indicator reports the utilization percentage of the <code>worker_1</code>.</p> <pre><code>utilization_res_1 = problem.add_indicator_resource_utilization(worker_1)\n</code></pre> <p>The <code>add_indicator_resource_cost</code> method returns the total cost of a resource (or a list of resource). It is computed using each cost function defined for each resource. In the following example, the indicator <code>cost_ind</code> is the total cost for both ressources <code>worker_1</code> and <code>worker_2</code>.</p> <pre><code>cost_ind = problem.add_indicator_resource_cost([worker_1, worker_2])\n</code></pre> <p>At last, the <code>add_indicator_number_tasks_assigned</code> method returns the number of tasks assigned to a resource after the schedule is completed.</p> <pre><code>problem.add_indicator_number_tasks_assigned(worker)\n</code></pre>"},{"location":"introduction/","title":"About","text":"<p>ProcessScheduler is a versatile tool designed to streamline operations in various industrial domains, including manufacturing, construction, healthcare, and more. It serves as a solution for tackling intricate scheduling challenges that defy straightforward resolutions.</p> <p>Within this toolkit, you'll find a rich array of features, including:</p> <ul> <li> <p>Task Definition: Define tasks with zero, fixed, or variable durations, along with work_amount specifications.</p> </li> <li> <p>Resource Management: Create and manage resources, complete with productivity and cost attributes. Efficiently assign resources to tasks.</p> </li> <li> <p>Temporal Task Constraints: Handle task temporal constraints such as precedence, fixed start times, and fixed end times.</p> </li> <li> <p>Resource Constraints: Manage resource availability and allocation.</p> </li> <li> <p>Logical Operations: Employ first-order logic operations to define relationships between tasks and resource constraints, including and/or/xor/not boolean operators, implications, if/then/else conditions.</p> </li> <li> <p>Multi-Objective Optimization: Optimize schedules across multiple objectives.</p> </li> <li> <p>Gantt Chart Visualization: Visualize schedules effortlessly with Gantt chart rendering, compatible with both matplotlib and plotly libraries.</p> </li> <li> <p>Export Capabilities: Seamlessly export solutions to JSON format and SMT problems to SMTLIB format.</p> </li> </ul> <p>This comprehensive guide will walk you through the process of model creation, solver execution, and solution analysis, making it a valuable resource for harnessing the full potential of ProcessScheduler.</p>"},{"location":"introduction/#whats-inside","title":"What's inside","text":"<p>ProcessScheduler operates on models written in the Python programming language, offering the flexibility to accommodate a wide range of scheduling requirements for tasks and resources.</p> <p>To tackle scheduling challenges, ProcessScheduler leverages the power of the Microsoft SMT Z3 Prover, an MIT licensed SMT solver. For those eager to delve deeper into the optimization aspects of the solver, a comprehensive reference can be found in the paper \"Bjorner et al. \u03bdZ - An Optimizing SMT Solver (2016).\" Additionally, an introductory guide to programming with Z3 in Python is available at z3-py-tutorial. It's worth noting that Z3 is the only mandatory dependency for ProcessScheduler.</p> <p>Furthermore, the tool offers the flexibility to visualize scheduling solutions by rendering them into Gantt charts, which can be exported in common formats such as JPG, PNG, PDF, or SVG. Please note that the optional libraries, matplotlib and plotly, are not pre-installed but can be easily integrated based on your preferences and needs.</p>"},{"location":"introduction/#downloadinstall","title":"Download/install","text":"<p>Use <code>pip</code> to install the package and the required dependencies (Z3) on your machine:</p> <p><pre><code>pip install ProcessScheduler\n</code></pre> and check the installation from a python3 prompt:</p> <pre><code>&gt;&gt;&gt; import processscheduler as ps\n</code></pre>"},{"location":"introduction/#development-version","title":"Development version","text":"<p>Create a local copy of the <code>github &lt;https://github.com/tpaviot/ProcessScheduler&gt;</code>_ repository:</p> <pre><code>git clone https://github.com/tpaviot/ProcessScheduler\n</code></pre> <p>Then install the development version:</p> <pre><code>cd ProcessScheduler\npip install -e .\n</code></pre>"},{"location":"objectives/","title":"Optimization","text":"<p>ProcessScheduler is able to compute optimized schedules according to one (single optimization) or any number (multi-objectives) of objectives.</p>"},{"location":"objectives/#objective","title":"Objective","text":"<p>An objective is a target value for an <code>Indicator</code> or any of the variables defined in the scheduling problem:</p> <ul> <li> <p>if the target value is known, then the objective can either be <code>ExactObjective</code>, <code>MinimumObjective</code> or <code>MaximumObjective</code>,</p> </li> <li> <p>it the target value is unknown but you want to find a minimal or maximal value, the the objective can be the result from an optimization resolution, <code>MaximizeObjective</code> or <code>MinimizeObjective</code>.</p> </li> </ul> <p>Warning</p> <p>Using <code>MaximizeObjective</code> or <code>MinimizeObjective</code> classes turn the problem into an optimization problem. This will result in heavier computations and, thus, a longer time for the problem to be solved.</p> <p>For example, if you need to optimize the utilization of a resource (bounded up to 100% within the problem horizon),</p> <pre><code># first create the indicator\nutilization_res_1 = problem.add_indicator_resource_utilization(worker_1)\n# the tell the solver to optimize this value\nps.MaximizeObjective(\"MaximizeResource1Utilization\", utilization_res_1)\n</code></pre>"},{"location":"objectives/#builtin-optimization-objectives","title":"Builtin optimization objectives","text":"<p>For any problem, the following builtin objectives are available:</p> <ul> <li> <p><code>add_objective_makespan</code>: minimize the schedule horizon,</p> </li> <li> <p><code>add_objective_resource_utilization</code>: maximize resource occupation,</p> </li> <li> <p><code>add_objective_resource_cost</code>: minimize the total cost for selected resource(s),</p> </li> <li> <p><code>add_objective_priorities</code>: minimize total priority indicator (tasks with high priorities will be scheduled before tasks with lower priorities, under the condition however that all constraints are satisfied),</p> </li> <li> <p><code>add_objective_start_earliest</code>: minimize the start time of the last task to be scheduled,</p> </li> <li> <p><code>add_objective_start_latest</code>: maximize the start time of the first task to be scheduled,</p> </li> <li> <p><code>add_objective_flowtime</code>: minimize flowtime.</p> </li> <li> <p><code>add_objective_flowtime_single_resource</code>: minimize flowtime of a single resource on a specific time interval</p> </li> </ul>"},{"location":"objectives/#available-solvers-incremental-and-optimize","title":"Available solvers : incremental and optimize","text":"<p>The default optimization solver is <code>incremental</code>. After a solution is found, the solver will run again and again to find a better solution untill the maximum allowed time is reached. If you provide a small max_time value, the solver will exit to the last found value, but there may be a better value. In that case, just increase the max_time and run again the solver.</p> <pre><code>solver = ps.SchedulingSolver(problem=pb,\n                             max_time=300)  # 300s is 5 minutes\nsolution = solver.solve()\n</code></pre> <p>The other available solver is called <code>optimize</code>, which use the builtin optsmt z3-solver. The computation cannot be interrupted, so be careful if the problem to solve involves many tasks/resources. However, the :func<code>optimize</code> is guaranteed to return the optimal value.</p> <pre><code>solver = ps.SchedulingSolver(problem=pb,\n                             optimizer=\"optimize\")  # 300s is 5 minutes\nsolution = solver.solve()\n</code></pre>"},{"location":"objectives/#single-objective-optimization","title":"Single objective optimization","text":"<p>Imagine you need to schedule one specific task <code>task_1</code> the later. After you defined the task as usual, then create the objective and set the optimization target:</p> <pre><code>pb = ps.SchedulingProblem(name='SingleObjective1', horizon=20)\ntask_1 = ps.FixedDurationTask(name='task1', duration = 3)\nindicator_1 = ps.Indicator(name='Task1End', task_1.end)\nps.MaximizeObjective(name='MaximizeTask1End', indicator_1)\nps.SchedulingSolver(pb).solve()\n</code></pre> <p>The expected value for the indicator_1 maximization is 20. After running the script, you may get the following output: <pre><code>Solver type:\n===========\n-&gt; Standard SAT/SMT solver\nIncremental optimizer:\n======================\nFound better value: 3 elapsed time:0.000s\nChecking better value &gt;3\nFound better value: 4 elapsed time:0.071s\nChecking better value &gt;4\n[...]\nChecking better value &gt;18\nFound better value: 19 elapsed time:0.074s\nChecking better value &gt;19\nFound better value: 20 elapsed time:0.074s\nChecking better value &gt;20\nNo solution can be found for problem MultiObjective2.\nReason: Unsatisfiable problem: no solution exists\nFound optimum 20. Stopping iteration.\ntotal number of iterations: 19\nvalue: 20\nMultiObjective2 satisfiability checked in 0.07s\n</code></pre></p> <p>The solver returns the expected result.</p>"},{"location":"objectives/#multiple-objective-optimization-using-the-incremental-solver-default","title":"Multiple objective optimization using the incremental solver (default)","text":"<p>ProcessScheduler can deal with multiple objectives optimization. There is no limitation regarding the number of objectives.</p> <p>Imagine you need to schedule two tasks <code>task_1</code> and <code>task_2</code> the later. After you defined the task as usual, then create the objective and set the optimization target:</p> <pre><code>pb = ps.SchedulingProblem('MultiObjective1', horizon=20)\ntask_1 = ps.FixedDurationTask('task1', duration = 3)\ntask_2 = ps.FixedDurationTask('task2', duration = 3)\nindicator_1 = ps.Indicator('Task1End', task_1.end)\nindicator_2 = ps.Indicator('Task2End', task_2.end)\nps.MaximizeObjective('MaximizeTask1End', indicator_1)\nps.MaximizeObjective('MaximizeTask2End', indicator_2)\nsolution = ps.SchedulingSolver(pb).solve()\nprint(solution)\n</code></pre> <p>After running the script, you may get the following output:</p> <pre><code>[...]\n{\n\"horizon\": 20,\n\"indicators\": {\n    \"EquivalentIndicator\": -40,\n    \"Task1End\": 20,\n    \"Task2End\": 20\n},\n[...]\n</code></pre> <p>The solver gives the expected result. Note that an EquivalentIndicator is built from both indicators. A maximization problem is always turned into a minimization problem (the equivalent indicator is negative).</p>"},{"location":"objectives/#weighted-objectives","title":"Weighted objectives","text":"<p>In the previous example, if we add a constraint between tasks <code>task_1</code> and <code>task_2</code>, then both tasks end may not be independent from each other. For example, let's add the following constraint:</p> <pre><code>pb.add_constraint(task_1.end == 20 - task_2.start)\n</code></pre> <p>This looks like a kind of balance: the later <code>task_1</code> is scheduled, the sooner <code>task_2</code> is scheduled. We can leave both optimizations enabled, but the solver has to know what to do with these conflicting objectives, and especially what is there relative weight.</p> <p>Note</p> <p>MaimizeObjective and MinimizeObjective have an optional <code>weight</code> parameter set by default to <code>1.0</code>. The higher this value, the more important the objective.</p> <p>The python script will look like</p> <pre><code>import processscheduler as ps\npb = ps.SchedulingProblem('MultiObjective2', horizon=20)\ntask_1 = ps.FixedDurationTask('task1', duration = 3)\ntask_2 = ps.FixedDurationTask('task2', duration = 3)\npb.add_constraint(task_1.end == 20 - task_2.start)\nindicator_1 = ps.Indicator('Task1End', task_1.end)\nindicator_2 = ps.Indicator('Task2End', task_2.end)\nps.MaximizeObjective('MaximizeTask1End', indicator_1, weight=1.)\nps.MaximizeObjective('MaximizeTask2End', indicator_2, weight=1.)\nsolution = ps.SchedulingSolver(pb).solve()\nprint(solution)\n</code></pre> <pre><code>\"indicators\": {\n    \"EquivalentIndicator\": -23,\n    \"Task1End\": 20,\n    \"Task2End\": 3\n},\n</code></pre> <p>The solver decides to schedule the Task1 at the end of the timeline. Let's change the relative weights so that the second objective is considered as more important:</p> <pre><code>ps.MaximizeObjective('MaximizeTask1End', indicator_1, weight=1.)\n# the second one is ten times more important\nps.MaximizeObjective('MaximizeTask2End', indicator_2, weight=10.)\n</code></pre> <p>This lead the solver to another solution:</p> <pre><code>\"indicators\": {\n    \"EquivalentIndicator\": -203,\n    \"Task1End\": 3,\n    \"Task2End\": 20\n},\n</code></pre>"},{"location":"objectives/#multiple-objective-optimization-using-the-optimize-solver-default","title":"Multiple objective optimization using the optimize solver (default)","text":""},{"location":"objectives/#lexicon-priority-lex-default","title":"Lexicon priority (<code>'lex'</code>, default)","text":"<p>The solver optimizes the first objective, then the second one while keeping the first value, then the third one keeping both previous values etc.</p> <p>In the previous example, the first objective to be optimized will be the end of task_1, obviously 20. Then, this value being fixed, there's no other solution than start of the second task is 0, then task_2 end will be 3.</p> <pre><code>ps.SchedulingSolver(pb, optimizer=optimize, optimize_priority='lex').solve()\n</code></pre> <p>And the output</p> <pre><code>Optimization results:\n=====================\n    -&gt;Objective priority specification: lex\n    -&gt;Objective values:\n        -&gt;Indicator_Task1End(max objective): 20\n        -&gt;Indicator_Task2End(max objective): 3\n</code></pre>"},{"location":"objectives/#box-priority-box","title":"Box priority (<code>'box'</code>)","text":"<p>The optimization solver breaks the dependency between objectives and look for the maximum (resp. minimum) value that can be achieved for each objective.</p> <p>In the previous example, the maximum of task_1end can be 20, and the maximum of task_2.end can also be 20, but not at the same time. The <code>box</code> priority then gives an information about the values that can be reached.</p> <pre><code>ps.SchedulingSolver(pb, optimizer=optimize, optimize_priority='box').solve()\n</code></pre> <p>And the output</p> <pre><code>Optimization results:\n=====================\n    -&gt;Objective priority specification: lex\n    -&gt;Objective values:\n        -&gt;Indicator_Task1End(max objective): 20\n        -&gt;Indicator_Task2End(max objective): 20\n</code></pre> <p>Note</p> <p>In <code>box</code> mode, both objectives may not be reached simultaneously, the solver will give anyway a solution that satisfies all constraints (by default the solution obtained from the lexicon mode).</p>"},{"location":"objectives/#pareto-priority-pareto","title":"Pareto priority (<code>'pareto'</code>)","text":"<p>The optimization solver suggests a new solution each time the <code>solve()</code> method is called. This allows traversing all solutions. Indeed we can have the task_1 end to 20 and task_2 end 3, but also the task_1 end to 19 and task_2 end to 4 etc. These all are solutions for the optimization problem.</p> <p>The python code has to be slightly modified:</p> <pre><code>solver = ps.SchedulingSolver(pb, optimizer=optimize, optimize_priority='pareto')\nwhile solver.solve():\n    pass\n</code></pre> <p>And the output will be:</p> <pre><code>Optimization results:\n=====================\n    -&gt;Objective priority specification: pareto\n    -&gt;Objective values:\n        -&gt;Indicator_Task1End(max objective): 20\n        -&gt;Indicator_Task2End(max objective): 3\nSAT computation time:\n=====================\n    MultiObjective2 satisfiability checked in 0.00s\nOptimization results:\n=====================\n    -&gt;Objective priority specification: pareto\n    -&gt;Objective values:\n        -&gt;Indicator_Task1End(max objective): 19\n        -&gt;Indicator_Task2End(max objective): 4\nSAT computation time:\n=====================\n    MultiObjective2 satisfiability checked in 0.00s\nOptimization results:\n=====================\n    -&gt;Objective priority specification: pareto\n    -&gt;Objective values:\n        -&gt;Indicator_Task1End(max objective): 18\n        -&gt;Indicator_Task2End(max objective): 5\n[...]\n</code></pre> <p>Here you have 18 different solutions. You can add a test to the loop to stop the iteration as soon as you're ok with the solution.</p>"},{"location":"resource/","title":"Resource","text":"<p>According to the APICS dictionary, a resource is anything that adds value to a product or service in its creation, production, or delivery.</p> <p>In the context of ProcessScheduler, a resource is anything that is needed by a task to be successfully processed. In a scheduling problem, resources can be human beings, machines, inventories, rooms or beds in an hotel or an hospital, elevator etc.</p> <p>ProcessScheduler provides the following classes to deal with resources: <code>Worker</code>, <code>CumulativeWorker</code> </p> <p>The inheritance class diagram is the following: <pre><code>classDiagram\n  Resource &lt;|-- Worker\n  Resource &lt;|-- CumulativeWorker</code></pre></p>"},{"location":"resource/#worker","title":"Worker","text":"<p>A Worker is an atomic, countable resource. Being atomic implies that it cannot be further divided into smaller parts, and being countable means it exists in a finite number, available during specific time intervals. The <code>Worker</code> class is ideal for representing entities like machines or humans. A <code>Worker</code> possesses the capacity to process tasks either individually or in collaboration with other workers or resources.</p> <p>To create a Worker, you can use the following syntax:</p> <pre><code>john = Worker(name='JohnBenis')\n</code></pre>"},{"location":"resource/#cumulativeworker","title":"CumulativeWorker","text":"<p>On the other hand, a <code>CumulativeWorker</code> can simultaneously handle multiple tasks in parallel. The maximum number of tasks that a <code>CumulativeWorker</code> can process concurrently is determined by the <code>size</code> parameter.</p> <p>For example, you can define a CumulativeWorker like this:</p> <pre><code># the machine A can process up to 4 tasks at the same time\nmachine_A = CumulativeWorker(name='MachineA',\n                             size=4)\n</code></pre>"},{"location":"resource/#resource-productivity","title":"Resource productivity","text":"<p>The <code>productivity</code> attribute of a worker represents the amount of work the worker can complete per period. By default, a worker's <code>productivity</code> is set to 0.</p> <p>For instance, if you have two drillers, with the first one capable of drilling 3 holes per period and the second one drilling 9 holes per period, you can define them as follows:</p> <pre><code>driller_1 = Worker(name='Driller1',\n                   productivity=3)\ndriller_2 = Worker(namme='Driller1',\n                   productivity=9)\n</code></pre> <p>Note</p> <p>The workers :const:<code>productivity</code> is used by the solver to satisfy the targeted task <code>work_amount</code> parameter value.</p>"},{"location":"resource/#resource-cost","title":"Resource cost","text":"<p>You can associate cost information with any resource, enabling ProcessScheduler to compute the total cost of a schedule, the cost per resource, or optimize the schedule to minimize costs (see the Objective section for details). There are two ways to define resource costs:</p>"},{"location":"resource/#constant-cost-per-period","title":"Constant Cost Per Period","text":"<p>In this approach, the resource's cost remains constant over time.</p> <pre><code>dev_1 = Worker(name='SeniorDeveloper',\n               cost=ConstantCostFunction(750))\n</code></pre> \\[C(t) = k, k \\in \\mathbb{N}\\]"},{"location":"resource/#linear-cost-function","title":"Linear Cost Function :","text":"\\[C(t)=slope * t + intercept, (slope, intercept) \\in \\mathbb{N} \\times \\mathbb{N}\\] <p>ml</p>"},{"location":"resource/#polynomial-cost-function","title":"Polynomial Cost Function","text":"\\[C(t)={a_n}t^n + {a_{n-1}}t^{n-1} + ... + {a_i}t^i + ... + {a_1}t+{a_0}\\] <p>This method allows you to represent resource costs as a polynomial function of time. It's particularly useful for modeling costs that are volatile (e.g., oil prices) or time-dependent (e.g., electricity costs). The cost parameter accepts any Python callable object.</p> <pre><code>def quadratic_time_function(t):\n    return (t-20)**2 + 154\ncost_function = PolynomialCostFunction(quadratic_time_function)\ndev_1 = Worker(name='AWorker',\n               cost=cost_function)\n</code></pre> <p>The worker <code>cost</code> is set to <code>None</code> by default.</p> <p>You can visualize the cost function using Matplotlib, which provides insights into how the cost evolves over time:</p> <p><pre><code>cost_function.plot([0, 200])\n</code></pre> </p> <p>Warning</p> <p>Currently, ProcessScheduler can handle integer numbers only. Then, all the coefficients of the polynomial must be integer numbers. If ever there are floating point numbers, no exception will be raised, but you might face strange results in the cost computation.</p> <p>Note</p> <p>The worker <code>cost_per_period</code> is useful to measure the total cost of a resource/a set of resources/a schedule, or to find the schedule that minimizes the total cost of a resource/a set of resources/ a schedule.</p>"},{"location":"resource_assignment/","title":"Resource assignment","text":"<p>In the context of scheduling, resource assignment is the process of determining which resource or resources should be assigned to a task for its successful processing. ProcessScheduler provides flexible ways to specify resource assignments for tasks, depending on your scheduling needs. A <code>Worker</code> instance can process only one task per time period whereas a <code>CumulativeWorker</code> can process multiple tasks at the same time.</p>"},{"location":"resource_assignment/#single-resource-assignment","title":"Single resource assignment","text":"<p>For assigning a single resource to a task, you can use the following syntax:</p> <pre><code>assemble_engine = FixedDurationTask(name='AssembleCarEngine',\n                                    duration=10)\njohn = Worker(name='JohnBenis')\n\n# the AssembleCarEngine can be processed by JohnBenis ONLY\nassemble_engine.add_required_resource(john)\n</code></pre>"},{"location":"resource_assignment/#multiple-resources-assignment","title":"Multiple resources assignment","text":"<p>To assign multiple resources to a single task, you can use the following approach:</p> <pre><code>paint_car = FixedDurationTask(name='PaintCar',\n                              duration=13)\n\njohn = Worker(name='JohnBenis')\nalice = Worker(name='AliceParker')\n\n# the PaintCar task requires JohnBenis AND AliceParker\npaint_engine.add_required_resources([john, alice])\n</code></pre>"},{"location":"resource_assignment/#alternative-resource-assignment","title":"Alternative resource assignment","text":"<p>ProcessScheduler introduces the <code>SelectWorkers</code> class, which allows the solver to decide which resource or resources to assign to a task from a collection of capable workers. You can specify whether the solver should assign exactly \\(n\\) resources, at most \\(n\\) resources, or at least \\(n\\) resources. Let's consider the following example: 3 drillers are available, a drilling task can be processed by any of one of these 3 drillers. This can be represented as:</p> <pre><code>drilling_hole = FixedDurationTask(name='DrillHolePhi10mm',\n                                  duration=10)\ndriller_1 = Worker(name='Driller1')\ndriller_2 = Worker(name='Driller2')\ndriller_3 = Worker(name='Driller3')\n\n# the DrillHolePhi10mm task can be processed by the Driller1 OR\n# the Driller2 OR the Driller 3\nsw = SelectWorkers(list_of_workers=[driller_1, driller_2, driller_3],\n                   nb_workers_to_select=1,\n                   kind='exact')\n\ndrilling_hole.add_required_resource(sw)\n</code></pre> <p>In this case, the solver is instructed to assign exactly one resource from the list of three workers capable of performing the task. The <code>kind</code> parameter can be set to <code>'exact'</code> (default), <code>'min'</code>, or <code>'max'</code>, depending on your requirements. Additionally, you can specify the number of workers to select with <code>nb_workers_to_select</code>, which can be any integer between 1 (default value) and the total number of eligible workers in the list.</p> <p>These resource assignment options provide flexibility and control over how tasks are allocated to available resources, ensuring efficient scheduling in various use cases.</p>"},{"location":"resource_constraints/","title":"Resource Constraints","text":"<p>ProcessScheduler provides a set of ready-to-use resource constraints. They allow expressing common rules such as \"the resource A is available only from 8 am to 12\" etc. There are a set of builtin ready-to-use constraints, listed below.</p> <pre><code>classDiagram\n  Constraint &lt;|-- ResourceConstraint\n  ResourceConstraint &lt;|-- WorkLoad\n  ResourceConstraint &lt;|-- ResourceUnavailable\n  ResourceConstraint &lt;|-- ResourceTasksDistance\n  ResourceConstraint &lt;|-- SameWorkers\n  ResourceConstraint &lt;|-- DistinctWorkers</code></pre>"},{"location":"resource_constraints/#workload","title":"WorkLoad","text":"<p>The <code>WorkLoad</code> constraint can be used to restrict the number of tasks which are executed during  certain time periods.</p> <p>This constraint applies to one resource, whether it is a single worker or a cumulative worker. It takes the time periods as a python dictionary composed of time intervals (the keys) and an integer number (the capacity). The <code>kind</code> parameter allows to define which kind of restriction applies to the resource: <code>'exact'</code>, <code>'max'</code> (default value) or <code>'min'</code>.</p> <pre><code> c1 = ps.WorkLoad(resource=worker_1,\n                  dict_time_intervals_and_bound={(0, 6): 2})\n</code></pre> <p>In the previous example, the resource <code>worker_1</code> cannot be scheduled into more than 2 timeslots between instants 0 and 6.</p> <p>Any number of time intervals can be passed to this class, just extend the timeslots dictionary, e.g.:</p> <pre><code>c1 = ps.WorkLoad(resource=worker_1,\n                 dict_time_intervals_and_bound={(0, 6): 2, (19, 21): 6})\n</code></pre> <p>The <code>WorkLoad</code> is not necessarily a limitation. Indeed you can specify that the integer number is actually an exact of minimal value to target. For example, if we need the resource <code>worker_1</code> to be scheduled at least into three time slots between instants 0 and 10, then:</p> <pre><code>c1 = ps.WorkLoad(resource=worker_1,\n                 dict_time_intervals_and_bound={(0, 10): 3},\n                 kind='min')\n</code></pre>"},{"location":"resource_constraints/#resourceunavailable","title":"ResourceUnavailable","text":"<p>A <code>ResourceUnavailable</code> applies to a resource and prevent the solver to schedule this resource during certain time periods. This class takes a list of intervals:</p> <pre><code>worker_1 = ps.Worker('Sylvia')\nca = ps.ResourceUnavailable(resource=worker_1,\n                            list_of_time_intervals=[(1,2), (6,8)])\n</code></pre> <p>The <code>ca</code> instance constraints the resource to be unavailable for 1 period between 1 and 2 instants, and for 2 periods between instants 6 and 8.</p> <p>Note</p> <p>This constraint is a special case for the <code>WorkLoad</code> where the <code>number_of_time_slots</code> is set to <code>0</code>.</p>"},{"location":"resource_constraints/#distinctworkers","title":"DistinctWorkers","text":"<p>A <code>AllDifferentWorkers</code> constraint applies to two <code>SelectWorkers</code> instances, used to assign alternative resources to a task. It constraints the solver to select different workers for each <code>SelectWorkers</code>. For instance:</p> <pre><code>s1 = ps.SelectWorkers(list_of_workers=[worker_1, worker_2])\ns2 = ps.SelectWorkers(list_of_workers=[worker_1, worker_2])\n</code></pre> <p>could lead the solver to select worker_1 in both cases. Adding the following line:</p> <pre><code>cs = ps.DistinctWorkers(select_workers_1=s1,\n                        select_workers_2=s2)\n</code></pre> <p>let the solver selects the worker_1 for s1 and worker_2 for s2 or the opposite, worker_2 for s1 and worker_1 for s2. The cases where worker_1 is selected by both s1 and s2 or worker_2 by selected by both s1 and s2 are impossible.</p>"},{"location":"resource_constraints/#sameworkers","title":"SameWorkers","text":"<p>A <code>AllSameWorkers</code> constraint applies to two <code>SelectWorkers</code> instances. It constraints the solver to ensure both different <code>SelectWorkers</code> instances select the same worker. For example:</p> <pre><code>s1 = ps.SelectWorkers(list_of_workers=[worker_1, worker_2])\ns2 = ps.SelectWorkers(list_of_workers=[worker_1, worker_2])\n</code></pre> <p>could lead the solver to select worker_1 for s1 and worker_2 for s2. Adding the following line:</p> <pre><code>cs = ps.SameWorkers(select_workers_1=s1,\n                    select_workers_2=s2)\n</code></pre> <p>ensures either worker_1 is selected by both s1 and s2, or worker_2 is selected by both s1 and s2.</p>"},{"location":"resource_constraints/#resourcetasksdistance","title":"ResourceTasksDistance","text":"<pre><code>worker_1 = ps.Worker(name=\"Worker1\")\n\nps.ResourceTasksDistance(\n    resource=worker_1,\n    distance=4,\n    mode=\"exact\",\n    list_of_time_intervals=[[10, 20], [30, 40]])\n</code></pre>"},{"location":"scheduling_problem/","title":"Scheduling problem","text":"<p>The <code>SchedulingProblem</code> class is the container for all modeling objects, such as tasks, resources and constraints.</p>"},{"location":"scheduling_problem/#time-slots-as-integers","title":"Time slots as integers","text":"<p>A <code>SchedulingProblem</code> instance holds a time interval: the lower bound of this interval (the initial time) is always 0, the upper bound (the final time) can be set by passing the <code>horizon</code> attribute to the <code>__init__</code> method:</p> <pre><code>my_problem = SchedulingProblem(name='MySchedulingProblem',\n                               horizon=20)\n</code></pre> <p>The interval's duration is subdivided into discrete units called periods, each with a fixed duration of 1. If \\(horizon\\) is set to a value, then the number of periods is equal to \\(horizon\\), and the number of points within the interval \\([0;horizon]\\) is \\(horizon+1\\).</p> <p></p> <p>Warning</p> <p>ProcessScheduler handles variables using integer values.</p> <p>A period represents the finest granularity level for defining the timeline, task durations, and the schedule itself. This timeline is dimensionless, allowing you to map a period to your desired duration, be it in seconds, minutes, hours, or any other unit. For instance:</p> <ul> <li>If you aim to schedule tasks within a single day, say from 8 am to 6 pm (office hours), resulting in a 10-hour time interval, and you plan to schedule tasks in 1-hour intervals, then the horizon value should be set to 10 to achieve the desired number of periods:</li> </ul> \\[horizon = \\frac{18-8}{1}=10\\] <ul> <li>If your task scheduling occurs in the morning, from 8 am to 12 pm, resulting in a 4-hour time interval, and you intend to schedule tasks in 1-minute intervals, then the horizon value must be 240:</li> </ul> \\[horizon = \\frac{12-8}{1/60}=240\\] <p>Note</p> <p>The <code>horizon</code> attribute is optional. If it's not explicitly provided during the <code>__init__</code> method, the solver will determine an appropriate horizon value that complies with the defined constraints. In cases where the scheduling problem aims to optimize the horizon, such as achieving a specific makespan objective, manual setting of the horizon is not necessary.</p>"},{"location":"scheduling_problem/#mapping-integers-to-datetime-objects","title":"Mapping integers to datetime objects","text":"<p>To enhance the readability of Gantt charts and make schedules more intuitive, ProcessScheduler allows you to represent time intervals in real dates and times rather than integers. You can explicitly set time values in seconds, minutes, hours, and more. The smallest time duration for a task, represented by the integer <code>1</code>, can be mapped to a Python <code>timedelta</code> object. Similarly, any point in time can be mapped to a Python <code>datetime</code> object.</p> <p>Creating Python timedelta objects can be achieved as follows:</p> <pre><code>from datetime import timedelta\ndelta = timedelta(days=50,\n                  seconds=27,\n                  microseconds=10,\n                  milliseconds=29000,\n                  minutes=5,\n                  hours=8,\n                  weeks=2)\n</code></pre> <p>For Python <code>datetime</code> objects, you can create them like this:</p> <pre><code>from datetime import datetime\nnow = datetime.now()\n</code></pre> <p>These attribute values can be provided to the SchedulingProblem initialization method as follows:</p> <pre><code>problem = ps.SchedulingProblem(name='DateTimeBase',\n                               horizon=7,\n                               delta_time=timedelta(minutes=15),\n                               start_time=datetime.now())\n</code></pre> <p>Once the solver has completed its work and generated a solution, you can export the end times, start times, and durations to the Gantt chart or any other output format.</p> <p>Note</p> <p>For more detailed information on Python's datetime package documentation and its capabilities, please refer to the datetime Python package documentation. This documentation provides comprehensive guidance on working with date and time objects in Python.</p>"},{"location":"solving/","title":"Problem solving","text":"<p>Solving a scheduling problem involves the <code>SchedulingSolver</code> class.</p>"},{"location":"solving/#solver-definition","title":"Solver definition","text":"<p>A <code>SchedulingSolver</code> instance takes a <code>SchedulingProblem</code> instance:</p> <pre><code>solver = SchedulingSolver(problem=scheduling_problem_instance)\n</code></pre> <p>It takes the following optional arguments:</p> <ul> <li> <p><code>debug</code>: False by default, if set to True will output many useful information.</p> </li> <li> <p><code>max_time</code>: in seconds, the maximal time allowed to find a solution. Default is 60s.</p> </li> <li> <p><code>parallel</code>: boolean False by default, if True force the solver to be executed in multithreaded mode. It might be quicker. It might not.</p> </li> <li> <p><code>random_values</code>: a boolean, default to :const:<code>False</code>. If set to :const:<code>True</code>, enable a builtin generator to set random initial values. By setting this attribute to :const:<code>True</code>, one expects the solver to give a different solution each time it is called.</p> </li> <li> <p><code>logics</code>: a string, None by default. Can be set to any of the supported z3 logics, \"QF_IDL\", \"QF_LIA\", etc. see https://smtlib.cs.uiowa.edu/logics.shtml. By default (logics set to None), the solver tries to find the best logics, but there can be significant improvements by setting a specific logics (\"QF_IDL\" or \"QF_UFIDL\" seems to give the best performances).</p> </li> <li> <p><code>verbosity</code>: an integer, 0 by default. 1 or 2 increases the solver verbosity. TO be used in a debugging or inspection purpose.</p> </li> </ul>"},{"location":"solving/#solve","title":"Solve","text":"<p>Just call the :func:<code>solve</code> method. This method returns a <code>Solution</code> instance.</p> <pre><code>solution = solver.solve()\n</code></pre> <p>Running the <code>solve</code> method returns can either fail or succeed, according to the 4 following cases:</p> <ol> <li>The problem cannot be solved because some constraints are contradictory. It is called \"Unsatisfiable\". The :func:<code>solve</code> method returns False. For example:</li> </ol> <pre><code>TaskStartAt(task=cook_the_chicken, value=2)\nTaskStartAt(task=cook_the_chicken, value=3)\n</code></pre> <p>It is obvious that these constraints cannot be both satisfied.</p> <ol> <li> <p>The problem cannot be solved for an unknown reason (the satisfiability of the set of constraints cannot be computed). The <code>solve</code> method returns False.</p> </li> <li> <p>The solver takes too long to complete and exceeds the allowed <code>max_time</code>. The <code>solve</code> method returns False.</p> </li> <li> <p>The solver successes in finding a schedule that satisfies all the constraints. The <code>solve</code> method returns the solution as a JSON dictionary.</p> </li> </ol> <p>Note</p> <p>If the solver fails to give a solution, increase the <code>max_time</code> (case 3) or remove some constraints (cases 1 and 2).</p>"},{"location":"solving/#find-another-solution","title":"Find another solution","text":"<p>The solver may schedule:</p> <ul> <li> <p>one solution among many, in the case where there is no optimization,</p> </li> <li> <p>the best possible schedule in case of an optimization issue.</p> </li> </ul> <p>In both cases, you may need to check a different schedule that fits all the constraints. Use the :func:<code>find_another_solution</code> method and pass the variable you would want the solver to look for another solution.</p> <p>Note</p> <p>Before requesting another solution, the <code>solve</code> method has first to be executed, i.e. there should already be a current solution.</p> <p>You can pass any variable to the <code>find_another_solution</code> method: a task start, a task end, a task duration, a resource productivity etc.</p> <p>For example, there are 5 different ways to schedule a FixedDurationTask with a duration=2 in an horizon of 6. The default solution returned by the solver is:</p> <pre><code>problem = ps.SchedulingProblem('FindAnotherSolution', horizon=6)\nsolutions =[]\ntask_1 = ps.FixedDurationTask('task1', duration=2)\nproblem.add_task(task_1)\nsolver = ps.SchedulingSolver(problem)\nsolution = solver.solve()\nprint(\"Solution for task_1.start:\", task_1.scheduled_start)\n</code></pre> <pre><code>Solution for task_1.start: 0\n</code></pre> <p>Then, we can request for another solution:</p> <pre><code>solution = solver.find_another_solution(task_1.start)\nif solution is not None:\n    print(\"New solution for task_1.start:\", solution.tasks[task_1.name].start)\n</code></pre> <pre><code>Solution for task_1.start: 1\n</code></pre> <p>You can recursively call <code>find_another_solution</code> to find all possible solutions, until the solver fails to return a new one.</p>"},{"location":"solving/#run-in-debug-mode","title":"Run in debug mode","text":"<p>If the <code>debug</code> attribute is set to True, the z3 solver is run with the unsat_core option. This will result in a much longer computation time, but this will help identifying the constraints that conflict. Because of this higher consumption of resources, the <code>debug</code> flag should be used only if the solver fails to find a solution.</p>"},{"location":"solving/#render-to-a-gantt-chart","title":"Render to a Gantt chart","text":"<p>Call the :func:<code>render_gantt_matplotlib</code> to render the solution as a Gantt chart. The time line is from 0 to <code>horizon</code> value, you can choose to render either <code>Task</code> or <code>Resource</code> (default).</p> <pre><code>solution = solver.solve()\nif solution is not None:\n    solution.render_gantt_matplotlib()  # default render_mode is 'Resource'\n    # a second gantt chart, in 'Task' mode\n    solution.render_gantt_matplotlib(render_mode='Task')\n</code></pre> <p>Call the <code>ps.render_gantt_plotly</code> to render the solution as a Gantt chart using plotly. Take care that plotly rendering needs real timepoints (set at least <code>delta_time</code> at the problem creation).</p> <pre><code>solution = solver.solve()\nif solution is not None:\n    # default render_mode is 'Resource'\n    solution.render_gantt_plotly(sort=\"Start\", html_filename=\"index.html\")\n    # a second gantt chart, in 'Task' mode\n    solution.render_gantt_plotly(render_mode='Task')\n</code></pre>"},{"location":"task/","title":"Task","text":"<p>According to the APICS dictionary, a task may either be:</p> <ol> <li> <p>In project management, the lowest level to which work can be divided on a project</p> </li> <li> <p>In activity-based cost accounting, a task, a subdivision of an activity, is the least amount of work. Tasks are used to describe activities.</p> </li> </ol> <p>In the context of this software library, the concept of a task aligns with the first definition. ProcessScheduler's primary objective is to compute a chronological sequence, or temporal order, for a collection of tasks while adhering to a specific set of constraints.</p> <p>The inheritance class diagram is the following: <pre><code>classDiagram\n  Task &lt;|-- ZeroDurationTask\n  Task &lt;|-- FixedDurationTask\n  Task &lt;|-- VariableDurationTask</code></pre></p>"},{"location":"task/#common-base-task-model","title":"Common base Task model","text":"<p>The <code>Task</code> class and its derivatives represent any task. A <code>Task</code> instance is defined by the three following parameters:</p> <ul> <li> <p><code>start</code>: a point in the \\([0, horizon]\\) integer interval. If the task is scheduled, then \\(start&gt;=0\\)</p> </li> <li> <p><code>end</code>: a point in the \\([0, horizon]\\) integer interval. If the task is scheduled, then \\(end&gt;=start\\) and \\(end&lt;=horizon\\)</p> </li> <li> <p><code>duration</code>: a integer number of periods, such as \\(duration=end-start\\)</p> </li> </ul> <p></p> <pre><code># Example: The duration of this task depends on the number\n# of workers handling boxes.\nmove_boxes = VariableDurationTask(name='MoveBoxesFromMachineAToInventory')\n</code></pre> <p>Warning</p> <p>Each <code>Task</code> instance must have a unique name in the scheduling problem. To prevent that two tasks share the same name, ProcessScheduler raises an exception if ever a task with an existing name is already created.</p> <p>Three <code>Task</code> derivative classes can be used to represent a task: <code>FixedDurationTask</code>, <code>ZeroDurationTask</code>, <code>VariableDurationTask</code>.</p>"},{"location":"task/#fixeddurationtask-class","title":"FixedDurationTask class","text":"<p>The duration of a <code>FixedDurationTask</code> is known a priori. You must pass the task <code>name</code> and <code>duration</code> arguments when creating the instance:</p> <pre><code># I assume one period to be mapped to 15min, cooking will be 1.5 hour\n# so the chicken requires 6*15mn=1.5h to be cooked\ncook_chicken = FixedDurationTask(name='CookChicken',\n                                 duration=6)\n</code></pre>"},{"location":"task/#zerodurationtask-class","title":"ZeroDurationTask class","text":"<p>A <code>ZeroDurationTask</code> is a FixedDurationTask where \\(duration=0\\), that is to say \\(start=end\\). Useful to represent project milestones, or other important points in time.</p> <pre><code>project_kickup = ZeroDurationTask(name='KickUp')\n</code></pre>"},{"location":"task/#variabledurationtask-class","title":"VariableDurationTask class","text":"<p>A <code>VariableDurationTask</code> represents a task for which the duration is not known. The solver is expected to find a duration that satisfies the constraints (the duration may depend on the number of resources assigned to the task). You can bound the duration by using <code>max_duration</code> and/or <code>min_duration</code> parameters.</p> <pre><code># 48h max to get done\nplant_wheat_seeds = VariableDurationTask(name='PlantWheatSeeds',\n                                         max_duration=48)\n</code></pre> <p>A <code>VariableDurationTask</code> duration can be selected among a list of possible durations. The solver decides the duration.</p> <pre><code># either 1 or 2 hour for an english lesson\nenglish_lesson = VariableDurationTask(name='EnglishLesson',\n                                      allowed_durations = [1, 2])\n</code></pre>"},{"location":"task/#advanced-parameters","title":"Advanced parameters","text":""},{"location":"task/#work-amount","title":"Work amount","text":"<p>The <code>work_amount</code> is the total amount of work that the <code>Task</code> must provide. It is set to :const:<code>0</code> by default. The <code>work_amount</code> is a dimensionless positive integer value, it can be mapped to any unit according to the physical meaning of the work amount. For example, if the task target is to move small pieces of wood from one point to another, then the work_amount maybe 166000 if 166000 pieces of woods are to be moved. In a maintenance task, if there are 8 screws to unscrew, the UnScrew work_amount will be set to 8.</p>"},{"location":"task/#temporal-priority","title":"Temporal priority","text":"<p>The <code>priority</code> of a task is a positive integer that can take any value. It is not bounded. A task with a higher priority will be scheduled earlier than a task with a lower priority. If the solver is requested to optimize the global schedule in terms of task priorities (a \"priority objective\") then a task with a high priority may be scheduled before a task with a lower priority.</p>"},{"location":"task/#optional","title":"Optional","text":"<p>All tasks instances are mandatory by default: the solver has to find a solution where all tasks are actually scheduled. However, tasks instances can be turned into optional tasks, by setting the <code>optional</code> flag to <code>True</code>:</p> <pre><code># 10mn to clean the table. This is an optional task\nclean_the_table_after_meal = FixedDurationTasks(name='CleanTable',\n                                                duration=10,\n                                                optional=True)\n</code></pre> <p>An optional task may or may not be scheduled by the solver. It depends on the constraints that bound the scheduling problem.</p>"},{"location":"task_constraints/","title":"Task Constraints","text":"<p>ProcessScheduler offers a comprehensive set of predefined temporal task constraints to help you express common scheduling rules efficiently. These constraints allow you to define task-related rules such as \"Task A must start exactly at time 4,\" \"Task B must end simultaneously with Task C,\" \"Task C should be scheduled precisely 3 periods after Task D,\" and more.</p> <p>Note</p> <p>Constraints that start with <code>Task*</code> apply to a single task, while those starting with <code>Task**s***</code> apply to two or more task instances.</p> <p>Note</p> <p>All Task constraints can be defined as either mandatory or optional. By default, constraints are mandatory (parameter optional=False). If you set the optional attribute to True, the constraint becomes optional and may or may not apply based on the solver's discretion. You can force the schedule to adhere to an optional constraint using the task.applied attribute:</p> <pre><code>pb.add_constraint([task.applied == True])\n</code></pre>"},{"location":"task_constraints/#single-task-temporal-constraints","title":"Single task temporal constraints","text":"<p>These constraints apply to individual tasks.</p>"},{"location":"task_constraints/#taskstartat","title":"TaskStartAt","text":"<p>Ensures that a tasks starts precisely at a specified time instant.</p> <p><code>TaskStartAt</code>: takes two parameters <code>task</code> and <code>value</code> such as the task starts exactly at the instant \\(\\(task.start = value\\)\\)</p>"},{"location":"task_constraints/#taskstartafter","title":"TaskStartAfter","text":"<p>Enforces that a task must start after a given time instant.</p> <p><code>TaskStartAfterStrict</code> can be strict lor lax.</p>"},{"location":"task_constraints/#taskendat","title":"TaskEndAt","text":"<p>Ensures that a task ends precisely at a specified time instant.</p> <p><code>TaskEndAt</code>: takes two parameters <code>task</code> and <code>value</code> such as the task ends exactly at the instant value :math:<code>task.end = value</code></p>"},{"location":"task_constraints/#taskendbefore","title":"TaskEndBefore","text":"<p>Requires that a task ends before or at a given time instant.</p> <p><code>TaskEndBeforeStrict</code> can be strict or lax.</p>"},{"location":"task_constraints/#two-tasks-temporal-constraints","title":"Two tasks temporal constraints","text":"<p>These constraints apply to sets of two tasks.</p>"},{"location":"task_constraints/#taskprecedence","title":"TaskPrecedence","text":"<p>Ensures that one task is scheduled before another. The precedence can be either 'lax,' 'strict,' or 'tight,' and an optional offset can be applied.</p> <p>The <code>TaskPrecedence</code> class takes two parameters <code>task_1</code> and <code>task_2</code> and constraints <code>task_2</code> to be scheduled after <code>task_1</code> is completed. The precedence type can either be :const:<code>'lax'</code> (default, <code>task_2.start</code> &gt;= <code>task_1.end</code>)), :const:<code>'strict'</code> (<code>task_2.start</code> &gt;= <code>task_1.end</code>)) or :const:<code>'tight'</code> (<code>task_2.start</code> &gt;= <code>task_1.end</code>, task_2 starts immediately after task_1 is completed). An optional parameter <code>offset</code> can be additionally set.</p> <p><pre><code>task_1 = ps.FixedDurationTask(name='Task1', duration=3)\ntask_2 = ps.FixedVariableTask(name='Task2')\npc = TaskPrecedence(task_before=task1,\n                    task_after=task2,\n                    kind='tight',\n                    offset=2)\n</code></pre> constraints the solver to schedule task_2 start exactly 2 periods after task_1 is completed.</p>"},{"location":"task_constraints/#tasksstartsynced","title":"TasksStartSynced","text":"<p>Specify that two tasks must start at the same time.</p> <p><code>TasksStartSynced</code> takes two parameters <code>task_1</code> and <code>task_2</code> such as the schedule must satisfy the constraint :math:<code>task_1.start = task_2.start</code></p> <p></p>"},{"location":"task_constraints/#tasksendsynced","title":"TasksEndSynced","text":"<p>Specify that two tasks must end at the same time.</p> <p><code>TasksEndSynced</code> takes two parameters <code>task_1</code> and <code>task_2</code> such as the schedule must satisfy the constraint :math:<code>task_1.end = task_2.end</code></p> <p></p>"},{"location":"task_constraints/#tasksdontoverlap","title":"TasksDontOverlap","text":"<p>Ensures that two tasks should not overlap in time.</p> <p><code>TasksDontOverlap</code> takes two parameters <code>task_1</code> and <code>task_2</code> such as the task_1 ends before the task_2 is started or the opposite (task_2 ends before task_1 is started)</p> <p></p>"},{"location":"task_constraints/#n-tasks-temporal-constraints","title":"\\(n\\) tasks temporal constraints","text":""},{"location":"task_constraints/#taskscontiguous","title":"TasksContiguous","text":"<p>Forces a set of tasks to be scheduled contiguously.</p> <p><code>TasksContiguous</code> takes a liste of tasks, force the schedule so that tasks are contiguous.</p>"},{"location":"task_constraints/#unorderedtaskgroup","title":"UnorderedTaskGroup","text":"<p>An UnorderedTaskGroup represents a collection of tasks that can be scheduled in any order. This means that the tasks within this group do not have a strict temporal sequence.</p>"},{"location":"task_constraints/#orderedtaskgroup","title":"OrderedTaskGroup","text":"<p>A set of tasks that can be scheduled in any order, with time bounds</p>"},{"location":"task_constraints/#advanced-tasks-constraints","title":"Advanced tasks constraints","text":""},{"location":"task_constraints/#schedulentasksintimeintervals","title":"ScheduleNTasksInTimeIntervals","text":"<p>Schedules a specific number of tasks within defined time intervals.</p> <p>Given a list of :math:<code>m</code> tasks, and a list of time intervals, <code>ScheduleNTasksInTimeIntervals</code> schedule :math:<code>N</code> tasks among :math:<code>m</code> in this time interval.</p>"},{"location":"task_constraints/#resourcetasksdistance","title":"ResourceTasksDistance","text":"<p>Defines constraints on the temporal distance between tasks using a shared resource.</p> <p><code>ResourceTasksDistance</code> takes a mandatory attribute <code>distance</code> (integer), an optional <code>time_periods</code> (list of couples of integers e.g. [[0, 1], [5, 19]]). All tasks, that use the given resource, scheduled within the <code>time_periods</code> must have a maximal distance of <code>distance</code> (distance being considered as the time between two consecutive tasks).</p> <p>Note</p> <p>If the task(s) is (are) optional(s), all these constraints apply only if the task is scheduled. If the solver does not schedule the task, these constraints does not apply.</p>"},{"location":"task_constraints/#logical-task-constraints","title":"Logical task constraints","text":""},{"location":"task_constraints/#optionaltaskconditionschedule","title":"OptionalTaskConditionSchedule","text":"<p>Creates a constraint that schedules a task based on a specified Boolean condition.</p> <p><code>OptionalTaskConditionSchedule</code> creates a constraint that adds a condition for the task to be scheduled. The condition is a z3 BoolRef</p>"},{"location":"task_constraints/#optionaltasksdependency","title":"OptionalTasksDependency","text":"<p><code>OptionalTasksDependency</code> takes two optional tasks <code>task_1</code> and <code>task_2</code>, and ensures that if task_1 is scheduled then that task_2 is forced to be scheduled as well.</p>"},{"location":"task_constraints/#forceschedulenoptionaltasks","title":"ForceScheduleNOptionalTasks","text":"<p>Forces the scheduling of a specified number of optional tasks out of a larger set of optional tasks.</p> <p><code>ForceScheduleNOptionalTasks</code> forces :math:<code>m</code> optional tasks among :math:<code>n</code> to be scheduled, with :math:<code>m \\leq n</code>.</p>"},{"location":"use-case-flow-shop/","title":"Use case: flowshop scheduling","text":"<p>This example is based on the paper from Tao et al. (2015), where authors present an introduction example. In a flow shop problem, a set of \\(n\\) jobs has to be processed on \\(m\\) different machines in the same order. Job \\(j\\), \\(j=1,2,...,n\\) is processed on machines \\(i\\), \\(i=1,2,..,m\\), with a nonnegative processing time \\(p(i,j)\\) and a release date \\(r_j\\), which is the earliest time when the job is permitted to process. Each machine can process at most one job and each job can be handled by at most one machine at any given time. The machine processes the jobs in a first come, first served manner. The goal is to determine a job sequence that minimizes the makespan.</p> <p>The problem statement is: </p> <p>The following solution is reported by the authors (order J1, J3, J4, J2, scheduled horizon: 29): </p> <p>In this notebook, we try to reproduce the results reported by the authors.</p> <p>Reference</p> <p>Tao Ren, Meiting Guo, Lin Lin, Yunhui Miao, \"A Local Search Algorithm for the Flow Shop Scheduling Problem with Release Dates\", Discrete Dynamics in Nature and Society, vol. 2015, Article ID 320140, 8 pages, 2015. https://doi.org/10.1155/2015/320140</p>"},{"location":"use-case-flow-shop/#imports","title":"Imports","text":"<pre><code>import processscheduler as ps\n\n%config InlineBackend.figure_formats = ['svg']\n</code></pre>"},{"location":"use-case-flow-shop/#create-the-scheduling-problem","title":"Create the scheduling problem","text":"<p>The total horizon is unknwown, leave it empty and only set the problem name.</p> <pre><code>flow_shop_problem = ps.SchedulingProblem(\"FlowShop\")\n</code></pre>"},{"location":"use-case-flow-shop/#create-the-3-machines-m1-m2-and-m3","title":"Create the 3 machines M1, M2 and M3","text":"<pre><code>M3 = ps.Worker(\"M3\")\nM2 = ps.Worker(\"M2\")\nM1 = ps.Worker(\"M1\")\n</code></pre>"},{"location":"use-case-flow-shop/#create-jobs-j1-j2-j3-and-j4-related-tasks","title":"Create jobs J1, J2, J3 and J4 - related tasks","text":"<pre><code># J1\nJ11 = ps.FixedDurationTask(\"J11\", duration=2)\nJ12 = ps.FixedDurationTask(\"J12\", duration=5)\nJ13 = ps.FixedDurationTask(\"J13\", duration=6)\n\n# J2\nJ21 = ps.FixedDurationTask(\"J21\", duration=1)\nJ22 = ps.FixedDurationTask(\"J22\", duration=5)\nJ23 = ps.FixedDurationTask(\"J23\", duration=7)\n\n# J3\nJ31 = ps.FixedDurationTask(\"J31\", duration=1)\nJ32 = ps.FixedDurationTask(\"J32\", duration=4)\nJ33 = ps.FixedDurationTask(\"J33\", duration=1)\n\n# J4\nJ41 = ps.FixedDurationTask(\"J41\", duration=3)\nJ42 = ps.FixedDurationTask(\"J42\", duration=4)\nJ43 = ps.FixedDurationTask(\"J43\", duration=7)\n</code></pre>"},{"location":"use-case-flow-shop/#assign-resources","title":"Assign resources","text":"<p>One machine per task.</p> <pre><code>J11.add_required_resource(M1)\nJ12.add_required_resource(M2)\nJ13.add_required_resource(M3)\n\nJ21.add_required_resource(M1)\nJ22.add_required_resource(M2)\nJ23.add_required_resource(M3)\n\nJ31.add_required_resource(M1)\nJ32.add_required_resource(M2)\nJ33.add_required_resource(M3)\n\nJ41.add_required_resource(M1)\nJ42.add_required_resource(M2)\nJ43.add_required_resource(M3)\n</code></pre>"},{"location":"use-case-flow-shop/#constraint-release-dates","title":"Constraint: release dates","text":"<pre><code>r1 = 0\nr2 = 9\nr3 = 2\nr4 = 7\n\nps.TaskStartAfter(J11, r1)\nps.TaskStartAfter(J12, r1)\nps.TaskStartAfter(J13, r1)\n\nps.TaskStartAfter(J21, r2)\nps.TaskStartAfter(J22, r2)\nps.TaskStartAfter(J23, r2)\n\nps.TaskStartAfter(J31, r3)\nps.TaskStartAfter(J32, r3)\nps.TaskStartAfter(J33, r3)\n\nps.TaskStartAfter(J41, r4)\nps.TaskStartAfter(J42, r4)\nps.TaskStartAfter(J43, r4)\n</code></pre>"},{"location":"use-case-flow-shop/#constraints-precedences","title":"Constraints: precedences","text":"<p>All jobs should be scheduled in the same ordre on each machine. The constraint is expressed as following: all J2 tasks must be scheduled before Or after J2 tasks, AND all J3 tasks must be scheduled before OR oafter J1 tasks etc.</p> <pre><code>J1 = [J11, J12, J13]\nJ2 = [J21, J22, J23]\nJ3 = [J31, J32, J33]\nJ4 = [J41, J42, J43]\n\n# we need to combinations function of the itertools module,\n# to compute all pairs from the list of jobs.\nfrom itertools import combinations\n\nfor Ja, Jb in combinations([J1, J2, J3, J4], 2):\n    befores = []\n    afters = []\n    for i in range(3):\n        Ja_before_Jb = ps.TaskPrecedence(Ja[i], Jb[i])\n        Ja_after_Jb = ps.TaskPrecedence(Jb[i], Ja[i])\n        befores.append(Ja_before_Jb)\n        afters.append(Ja_after_Jb)\n    xor_operation = ps.xor_([ps.and_(befores), ps.and_(afters)])\n    flow_shop_problem.add_constraint(xor_operation)\n</code></pre>"},{"location":"use-case-flow-shop/#add-a-makespan-objective","title":"Add  a makespan objective","text":"<pre><code>makespan_obj = flow_shop_problem.add_objective_makespan()\n</code></pre>"},{"location":"use-case-flow-shop/#solution-plot-the-schedule","title":"Solution, plot the schedule","text":"<pre><code>solver = ps.SchedulingSolver(flow_shop_problem)\nsolution = solver.solve()\nsolution.render_gantt_matplotlib(fig_size=(10, 5), render_mode=\"Resource\")\n</code></pre> <p>We confirm the job sort from Tao et al. (2015) (J1 then J3, J4 and finally J2). The horizon is here only 21.</p>"},{"location":"use-case-formula-one-change-tires/","title":"Use case: formula one pitstop","text":"<p>This example is based on the DailyMail blog entry https://www.dailymail.co.uk/sport/formulaone/article-4401632/Formula-One-pit-stop-does-crew-work.html where a nice image shows 21 people changing the 4 tires of a Formula 1 Ferrari. In this example, only 16 out 21 people are represented. This notebook can be tested online at mybinder.org </p> <pre><code>from IPython.display import YouTubeVideo\n\nYouTubeVideo(\"aHSUp7msCIE\", width=800, height=300)\n</code></pre>"},{"location":"use-case-formula-one-change-tires/#imports","title":"Imports","text":"<pre><code>import processscheduler as ps\n\n%config InlineBackend.figure_formats = ['svg']\n</code></pre>"},{"location":"use-case-formula-one-change-tires/#create-the-scheduling-problem","title":"Create the scheduling problem","text":"<p>The total horizon is not knwown, leave it empty and only set the problem name.</p> <pre><code>change_tires_problem = ps.SchedulingProblem(\"ChangeTires\")\n</code></pre>"},{"location":"use-case-formula-one-change-tires/#create-the-16-available-resources","title":"Create the 16 available resources","text":"<p>Each people in and around the car is represented as a worker.</p> <pre><code>nb_lifters = 2\nnb_gunners = 4\nnb_tyre_handlers = 8\nnb_stabilizers = 2\n</code></pre> <pre><code># Lift tasks\nlifters = [ps.Worker(\"JackOperator%i\" % (i + 1)) for i in range(nb_lifters)]\ngunners = [ps.Worker(\"Gunner%i\" % (i + 1)) for i in range(nb_gunners)]\ntyre_handlers = [ps.Worker(\"Handler%i\" % (i + 1)) for i in range(nb_tyre_handlers)]\nstabilizers = [ps.Worker(\"Stabilizer%i\" % (i + 1)) for i in range(nb_stabilizers)]\n</code></pre>"},{"location":"use-case-formula-one-change-tires/#create-tasks-and-assign-resources","title":"Create tasks and assign resources","text":"<p>One period is mapped to one second. For example, if lifting the rear take 2sec then the duration will be set to 2.</p> <pre><code># lift tasks and lifters\n# both lift tasks can be processed by any one of the lifters\nlift_rear_up = ps.FixedDurationTask(\"LiftRearUp\", duration=2)\nlift_front_up = ps.FixedDurationTask(\"LiftFrontUp\", duration=2)\nlift_rear_up.add_required_resource(lifters[0])\nlift_front_up.add_required_resource(lifters[1])\n\nlift_rear_down = ps.FixedDurationTask(\"LiftRearDown\", duration=2)\nlift_front_down = ps.FixedDurationTask(\"LiftFrontDown\", duration=2)\nlift_rear_down.add_required_resource(lifters[0])\nlift_front_down.add_required_resource(lifters[1])\n\n# unscrew tasks\nunscrew_front_left_tyre = ps.FixedDurationTask(\"UnScrewFrontLeftTyre\", duration=2)\nunscrew_front_right_tyre = ps.FixedDurationTask(\"UnScrewFrontRightTyre\", duration=2)\nunscrew_rear_left_tyre = ps.FixedDurationTask(\"UnScrewRearLeftTyre\", duration=2)\nunscrew_rear_right_tyre = ps.FixedDurationTask(\"UnScrewRearRightTyre\", duration=2)\n\ngunner_unscrew_front_left_tyre = ps.SelectWorkers(gunners, 1)\nunscrew_front_left_tyre.add_required_resource(gunner_unscrew_front_left_tyre)\n\ngunner_unscrew_front_right_tyre = ps.SelectWorkers(gunners, 1)\nunscrew_front_right_tyre.add_required_resource(gunner_unscrew_front_right_tyre)\n\ngunner_unscrew_rear_left_tyre = ps.SelectWorkers(gunners, 1)\nunscrew_rear_left_tyre.add_required_resource(gunner_unscrew_rear_left_tyre)\n\ngunner_unscrew_rear_right_tyre = ps.SelectWorkers(gunners, 1)\nunscrew_rear_right_tyre.add_required_resource(gunner_unscrew_rear_right_tyre)\n\n# screw tasks and gunners\nscrew_front_left_tyre = ps.FixedDurationTask(\"ScrewFrontLeftTyre\", duration=2)\nscrew_front_right_tyre = ps.FixedDurationTask(\"ScrewFrontRightTyre\", duration=2)\nscrew_rear_left_tyre = ps.FixedDurationTask(\"ScrewRearLeftTyre\", duration=2)\nscrew_rear_right_tyre = ps.FixedDurationTask(\"ScrewRearRightTyre\", duration=2)\n\ngunner_screw_front_left_tyre = ps.SelectWorkers(gunners)\nscrew_front_left_tyre.add_required_resource(gunner_screw_front_left_tyre)\n\ngunner_screw_front_right_tyre = ps.SelectWorkers(gunners)\nscrew_front_right_tyre.add_required_resource(gunner_screw_front_right_tyre)\n\ngunner_screw_rear_left_tyre = ps.SelectWorkers(gunners)\nscrew_rear_left_tyre.add_required_resource(gunner_screw_rear_left_tyre)\n\ngunner_screw_rear_right_tyre = ps.SelectWorkers(gunners)\nscrew_rear_right_tyre.add_required_resource(gunner_screw_rear_right_tyre)\n</code></pre> <pre><code># tires OFF and handlers\nfront_left_tyre_off = ps.FixedDurationTask(\"FrontLeftTyreOff\", duration=2)\nfront_right_tyre_off = ps.FixedDurationTask(\"FrontRightTyreOff\", duration=2)\nrear_left_tyre_off = ps.FixedDurationTask(\"RearLeftTyreOff\", duration=2)\nrear_right_tyre_off = ps.FixedDurationTask(\"RearRightTyreOff\", duration=2)\n\nfor tyre_off_task in [\n    front_left_tyre_off,\n    front_right_tyre_off,\n    rear_left_tyre_off,\n    rear_right_tyre_off,\n]:\n    tyre_off_task.add_required_resource(ps.SelectWorkers(tyre_handlers))\n\n# tires ON and handlers, same as above\nfront_left_tyre_on = ps.FixedDurationTask(\"FrontLeftTyreOn\", duration=2)\nfront_right_tyre_on = ps.FixedDurationTask(\"FrontRightTyreOn\", duration=2)\nrear_left_tyre_on = ps.FixedDurationTask(\"RearLeftTyreOn\", duration=2)\nrear_right_tyre_on = ps.FixedDurationTask(\"RearRightTyreOn\", duration=2)\n\nfor tyre_on_task in [\n    front_left_tyre_on,\n    front_right_tyre_on,\n    rear_left_tyre_on,\n    rear_right_tyre_on,\n]:\n    tyre_on_task.add_required_resource(ps.SelectWorkers(tyre_handlers))\n</code></pre> <p>Stabilizers start their job as soon as the car is stopped until the end of the whole activity.</p> <pre><code>stabilize_left = ps.VariableDurationTask(\"StabilizeLeft\")\nstabilize_right = ps.VariableDurationTask(\"StabilizeRight\")\n\nstabilize_left.add_required_resource(stabilizers[0])\nstabilize_right.add_required_resource(stabilizers[1])\n\nps.TaskStartAt(stabilize_left, 0)\nps.TaskStartAt(stabilize_right, 0)\n\nps.TaskEndAt(stabilize_left, change_tires_problem.horizon)\nps.TaskEndAt(stabilize_right, change_tires_problem.horizon)\n</code></pre>"},{"location":"use-case-formula-one-change-tires/#task-precedences","title":"Task precedences","text":"<pre><code># front left tyre operations\nfr_left = [\n    unscrew_front_left_tyre,\n    front_left_tyre_off,\n    front_left_tyre_on,\n    screw_front_left_tyre,\n]\nfor i in range(len(fr_left) - 1):\n    ps.TaskPrecedence(fr_left[i], fr_left[i + 1])\n# front right tyre operations\nfr_right = [\n    unscrew_front_right_tyre,\n    front_right_tyre_off,\n    front_right_tyre_on,\n    screw_front_right_tyre,\n]\nfor i in range(len(fr_right) - 1):\n    ps.TaskPrecedence(fr_right[i], fr_right[i + 1])\n# rear left tyre operations\nre_left = [\n    unscrew_rear_left_tyre,\n    rear_left_tyre_off,\n    rear_left_tyre_on,\n    screw_rear_left_tyre,\n]\nfor i in range(len(re_left) - 1):\n    ps.TaskPrecedence(re_left[i], re_left[i + 1])\n# front left tyre operations\nre_right = [\n    unscrew_rear_right_tyre,\n    rear_right_tyre_off,\n    rear_right_tyre_on,\n    screw_rear_right_tyre,\n]\nfor i in range(len(re_right) - 1):\n    ps.TaskPrecedence(re_right[i], re_right[i + 1])\n\n# all un screw operations must start after the car is lift by both front and rear jacks\nfor unscrew_tasks in [\n    unscrew_front_left_tyre,\n    unscrew_front_right_tyre,\n    unscrew_rear_left_tyre,\n    unscrew_rear_right_tyre,\n]:\n    ps.TaskPrecedence(lift_rear_up, unscrew_tasks)\n    ps.TaskPrecedence(lift_front_up, unscrew_tasks)\n\n# lift down operations must occur after each screw task is completed\nfor screw_task in [\n    screw_front_left_tyre,\n    screw_front_right_tyre,\n    screw_rear_left_tyre,\n    screw_rear_right_tyre,\n]:\n    ps.TaskPrecedence(screw_task, lift_rear_down)\n    ps.TaskPrecedence(screw_task, lift_front_down)\n</code></pre>"},{"location":"use-case-formula-one-change-tires/#first-solution-plot-the-schedule","title":"First solution, plot the schedule","text":"<pre><code>solver = ps.SchedulingSolver(change_tires_problem)\nsolution_1 = solver.solve()\nsolution_1.render_gantt_matplotlib(fig_size=(10, 5), render_mode=\"Resource\")\n</code></pre>"},{"location":"use-case-formula-one-change-tires/#second-solution-add-a-makespan-objective","title":"Second solution: add a makespan objective","text":"<p>Obviously, the former solution is not the best solution, not sure Ferrari will win this race ! The whole \"change tires\" activity must be as short as possible, so let's add a makespan objective, i.e. a constraint that minimizes the schedule horizon.</p> <pre><code># add makespan objective\nchange_tires_problem.add_objective_makespan()\n\nsolver_2 = ps.SchedulingSolver(change_tires_problem)\nsolution_2 = solver_2.solve()\nsolution_2.render_gantt_matplotlib(fig_size=(9, 5), render_mode=\"Task\")\n</code></pre>"},{"location":"use-case-formula-one-change-tires/#third-solution-constraint-workers","title":"Third solution: constraint workers","text":"<p>This is not the best possible solution. Indeed, we can notice that the Gunner2 unscrews the RearRightTyre and screw the RearLeft tyre. We cannot imagine that a solution where gunners turn around the car is acceptable. There are two solutions to fix the schedule: -   let the gunner be able to turn around the car, and add a \"Move\" task with a duration that represent the time necessary to move from one tyre to the other, -   constraint the worker to screw the same tyre he unscrewed. Let's go this way</p> <pre><code>ps.SameWorkers(gunner_unscrew_front_left_tyre, gunner_screw_front_left_tyre)\nps.SameWorkers(gunner_unscrew_front_right_tyre, gunner_screw_front_right_tyre)\nps.SameWorkers(gunner_unscrew_rear_left_tyre, gunner_screw_rear_left_tyre)\nps.SameWorkers(gunner_unscrew_rear_right_tyre, gunner_screw_rear_right_tyre)\n\nsolver_3 = ps.SchedulingSolver(change_tires_problem)\nsolution_3 = solver_3.solve()\nsolution_3.render_gantt_matplotlib(fig_size=(9, 5), render_mode=\"Task\")\n</code></pre> <p>This is much better !</p>"},{"location":"use-case-software-development/","title":"Use case: software development","text":"<p>To illustrate the way to use ProcessScheduler, let's imagine the simple following use case: the developmenent of a scheduling software intended for end-user. The software is developed using Python, and provides a modern Qt GUI. Three junior developers are in charge (Elias, Louis, Elise), under the supervision of their project manager Justine. The objective of this document is to generate a schedule of the different developmenent tasks to go rom the early design stages to the first software release. This notebook can tested online at mybinder.org </p>"},{"location":"use-case-software-development/#step-1-import-the-module","title":"Step 1. Import the module","text":"<p>The best way to import the processscheduler module is to choose an alias import. Indeed, a global import should generate name conflicts. Here, the ps alias is used.</p> <pre><code>import processscheduler as ps\nfrom datetime import timedelta, datetime\n\n%config InlineBackend.figure_formats = ['svg']\n</code></pre>"},{"location":"use-case-software-development/#step-2-create-the-scheduling-problem","title":"Step 2. Create the scheduling problem","text":"<p>The SchedulingProblem has to be defined. The problem must have a name (it is a mandatory argument). Of course you can create as many problems (i.e; SchedulingProblem instances), for example if you need to compare two or more different schedules.</p> <pre><code>problem = ps.SchedulingProblem(\n    \"SoftwareDevelopment\", delta_time=timedelta(days=1), start_time=datetime.now()\n)\n</code></pre>"},{"location":"use-case-software-development/#step-3-create-tasks-instances","title":"Step 3. Create tasks instances","text":"<p>The SchedulingProblem has to be defined. The problem must have a name (it is a mandatory argument). Of course you can create as many problems (i.e SchedulingProblem instances) as needed, for example if you need to compare two or more different schedules. In this example, one period is one day.</p> <pre><code>preliminary_design = ps.FixedDurationTask(\"PreliminaryDesign\", duration=1)  # 1 day\ncore_development = ps.VariableDurationTask(\"CoreDevelopmenent\", work_amount=10)\ngui_development = ps.VariableDurationTask(\"GUIDevelopment\", work_amount=15)\nintegration = ps.VariableDurationTask(\"Integration\", work_amount=3)\ntests_development = ps.VariableDurationTask(\"TestDevelopment\", work_amount=8)\nrelease = ps.ZeroDurationTask(\"ReleaseMilestone\")\n</code></pre>"},{"location":"use-case-software-development/#step-4-create-tasks-time-constraints","title":"Step 4. Create tasks time constraints","text":"<p>Define precedences or set start and end times</p> <pre><code>ps.TaskStartAt(preliminary_design, 0)\nps.TaskPrecedence(preliminary_design, core_development)\nps.TaskPrecedence(preliminary_design, gui_development)\nps.TaskPrecedence(gui_development, tests_development)\nps.TaskPrecedence(core_development, tests_development)\nps.TaskPrecedence(tests_development, integration)\nps.TaskPrecedence(integration, release)\n</code></pre>"},{"location":"use-case-software-development/#step-5-create-resources","title":"Step 5. Create resources","text":"<p>Define all resources required for all tasks to be processed, including productivity and cost_per_period.</p> <pre><code>elias = ps.Worker(\n    \"Elias\", productivity=2, cost=ps.ConstantCostPerPeriod(600)\n)  # cost in $/day\nlouis = ps.Worker(\"Louis\", productivity=2, cost=ps.ConstantCostPerPeriod(600))\nelise = ps.Worker(\"Elise\", productivity=3, cost=ps.ConstantCostPerPeriod(800))\njustine = ps.Worker(\"Justine\", productivity=2, cost=ps.ConstantCostPerPeriod(1200))\n</code></pre>"},{"location":"use-case-software-development/#step-6-assign-resources-to-tasks","title":"Step 6. Assign resources to tasks","text":"<pre><code>preliminary_design.add_required_resources([elias, louis, elise, justine])\ncore_development.add_required_resources([louis, elise])\ngui_development.add_required_resources([elise])\ntests_development.add_required_resources([elias, louis])\nintegration.add_required_resources([justine])\nrelease.add_required_resources([justine])\n</code></pre>"},{"location":"use-case-software-development/#step-7-add-a-total-cost-indicator","title":"Step 7. Add a total cost indicator","text":"<p>This resource cost indicator computes the total cost of selected resources.</p> <pre><code>cost_ind = problem.add_indicator_resource_cost([elias, louis, elise, justine])\n</code></pre>"},{"location":"use-case-software-development/#step-8-solve-and-plot-using-plotly","title":"Step 8. Solve and plot using plotly","text":"<pre><code># solve\nsolver = ps.SchedulingSolver(problem)\nsolution = solver.solve()\n</code></pre> <pre><code>if solution:\n    solution.render_gantt_plotly()\n</code></pre>"}]}